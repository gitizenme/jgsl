/* Generated By:JavaCC: Do not edit this line. JGSL_Parser.java */
package jgsl.parser;


import jgsl.io.ScriptMessage;
import jgsl.io.ScriptWarning;
import jgsl.io.ScriptError;
import jgsl.io.ScriptParserException;
import jgsl.io.ScriptParserUtil;

import jgsl.model.JGSLDouble;
import jgsl.model.JGSLInteger;
import jgsl.model.JGSLString;
import jgsl.model.JGSLColor;
import jgsl.model.JGSLScript;
import jgsl.model.Assignment;
import jgsl.model.Command;
import jgsl.model.Declaration;
import jgsl.model.Documentation;
import jgsl.model.Logical;
import jgsl.model.Statement;

import java.awt.Color;
import java.util.ArrayList;

/**
 *
 * @author zenarchitect
 * @version $Id: JGSL_Parser.java,v 1.11 2005/05/24 17:32:19 zenarchitect Exp $
 */

public class JGSL_Parser implements JGSL_ParserConstants {

  private JGSLScript script = new JGSLScript();

  public JGSLScript getScript() {
      return script;
  }

  public static void main(String args[]) throws ParseException {
        JGSL_Parser parser;
        String filename = null;
        long initTime = 0;
        long parseTime = 0;
        long startTime = 0;
        long stopTime = 0;
        if (args.length == 0)
        {
            System.out.println("jgsl parser:  Reading from standard input . . .");
            parser = new JGSL_Parser(System.in);
        } else if (args.length == 1)
        {
            filename = args[0];
            System.out.println("jgsl parser:  Reading from file " + filename + " . . .");
            try
            {
                startTime = System.currentTimeMillis();
                parser = new JGSL_Parser(new java.io.FileInputStream(filename));
                stopTime = System.currentTimeMillis();
                initTime = stopTime - startTime;
            } catch (java.io.FileNotFoundException e)
            {
                System.out.println("jgsl parser:  File " + filename + " not found.");
                return;
            }
        } else
        {
            System.out.println("jgsl parser:  Usage is one of:");
            System.out.println("         java jsgl.JSGL < <stdin>");
            System.out.println("OR");
            System.out.println("         java jsgl.JSGL inputfile");
            return;
        }
        try
        {
            startTime = System.currentTimeMillis();
            parser.parseScript();
            stopTime = System.currentTimeMillis();
            parseTime = stopTime - startTime;
            System.out.println("jgsl parser: ");
            System.out.println("   JGSL file parsed " + filename + " successfully in " + (initTime + parseTime) + " ms.");
            System.out.println("      initialization time = " + initTime + " ms.");
            System.out.println("      parse time = " + parseTime + " ms.");
        } catch (ParseException e)
        {
            System.out.println(e.getMessage());
            System.out.println("jgsl parser:  Encountered errors during parse.");
        }
  }

/*
<comments | documentation>*

<BEGIN>

<attributes | commands | comments | documentation>

<END>

*/

/*****************************************
 * THE JGSL GRAMMAR STARTS HERE          *
 *****************************************/

/*
 * Program structuring syntax follows.
 */
  final public void parseScript() throws ParseException {
    Script();
  }

  final public void Script() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOC:
        ;
        break;
      default:
        jj_la1[0] = jj_gen;
        break label_1;
      }
      Documentation();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BEGIN:
      ScriptBody();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    jj_consume_token(0);
  }

  final public void Documentation() throws ParseException {
    Token doc;
    jj_consume_token(DOC);
    doc = jj_consume_token(STRING_LITERAL);
    script.addDocumentation(doc.image);
  }

  final public void ScriptBody() throws ParseException {
    jj_consume_token(BEGIN);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLEAR:
      case CANVAS:
      case DRAW:
      case TEXT:
      case RECTANGLE:
      case SQUARE:
      case CIRCLE:
      case ELIPSE:
      case ARC:
      case POLYGON:
      case LINE:
      case WAIT:
      case LOG:
      case DEBUG:
      case ERROR:
      case WARNING:
      case DECLARE:
      case DOC:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CLEAR:
      case CANVAS:
      case DRAW:
      case TEXT:
      case RECTANGLE:
      case SQUARE:
      case CIRCLE:
      case ELIPSE:
      case ARC:
      case POLYGON:
      case LINE:
      case WAIT:
      case LOG:
      case DEBUG:
      case ERROR:
      case WARNING:
        Command();
        break;
      case DECLARE:
        Declaration();
        break;
      case IDENTIFIER:
        Assignment();
        break;
      case DOC:
        Documentation();
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    jj_consume_token(END);
  }

  final public void Command() throws ParseException {
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CANVAS:
        Canvas();
        break;
      case CLEAR:
        Clear();
        break;
      case WAIT:
        Wait();
        break;
      case DRAW:
        Draw();
        break;
      case RECTANGLE:
      case SQUARE:
      case CIRCLE:
      case ELIPSE:
      case ARC:
      case POLYGON:
      case LINE:
        DrawShape();
        break;
      case TEXT:
        DrawText();
        break;
      case LOG:
      case DEBUG:
      case ERROR:
      case WARNING:
        Log();
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(SEMICOLON);
    } catch (ParseException e) {
         error_skipto(SEMICOLON);
    }
  }

  void error_skipto(int kind) throws ParseException {
    ParseException e = generateParseException();  // generate the exception object.

    ScriptError se = new ScriptError(e.getMessage());
    script.addError(se);

    Token t;
    do {
    t = getNextToken();
    } while (t.kind != kind);
  }

  final public void Clear() throws ParseException {
    Token name;
    name = jj_consume_token(CLEAR);
        Command c = new Command(name.image);
        script.add(c);
  }

  final public Color GetStandardColor() throws ParseException {
    Token value;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BLACK:
        value = jj_consume_token(BLACK);
        break;
      case BLUE:
        value = jj_consume_token(BLUE);
        break;
      case DARK_GRAY:
        value = jj_consume_token(DARK_GRAY);
        break;
      case GRAY:
        value = jj_consume_token(GRAY);
        break;
      case GREEN:
        value = jj_consume_token(GREEN);
        break;
      case LIGHT_GRAY:
        value = jj_consume_token(LIGHT_GRAY);
        break;
      case MAGENTA:
        value = jj_consume_token(MAGENTA);
        break;
      case ORANGE:
        value = jj_consume_token(ORANGE);
        break;
      case PINK:
        value = jj_consume_token(PINK);
        break;
      case RED:
        value = jj_consume_token(RED);
        break;
      case WHITE:
        value = jj_consume_token(WHITE);
        break;
      case YELLOW:
        value = jj_consume_token(YELLOW);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
        ScriptError se = new ScriptError(e.getMessage());
        script.addError(se);
        {if (true) return null;}
    }
//        Color color = Color.RED;
        String colorName = value.image.toLowerCase();
        if(colorName.equals("black")) {
            {if (true) return Color.BLACK;}
        }
        else if(colorName.equals("blue")) {
            {if (true) return Color.BLUE;}
        }
        else if(colorName.equals("dark_gray")) {
            {if (true) return Color.DARK_GRAY;}
        }
        else if(colorName.equals("gray")) {
            {if (true) return Color.GRAY;}
        }
        else if(colorName.equals("green")) {
            {if (true) return Color.GREEN;}
        }
        else if(colorName.equals("light_gray")) {
            {if (true) return Color.LIGHT_GRAY;}
        }
        else if(colorName.equals("magenta")) {
            {if (true) return Color.MAGENTA;}
        }
        else if(colorName.equals("orange")) {
            {if (true) return Color.ORANGE;}
        }
        else if(colorName.equals("pink")) {
            {if (true) return Color.PINK;}
        }
        else if(colorName.equals("red")) {
            {if (true) return Color.RED;}
        }
        else if(colorName.equals("white")) {
            {if (true) return Color.WHITE;}
        }
        else if(colorName.equals("yellow")) {
            {if (true) return Color.YELLOW;}
        }
    throw new Error("Missing return statement in function");
  }

  final public Color GetRGB() throws ParseException {
    Token r;
    Token g;
    Token b;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      r = jj_consume_token(INTEGER_LITERAL);
      jj_consume_token(COMMA);
      g = jj_consume_token(INTEGER_LITERAL);
      jj_consume_token(COMMA);
      b = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      r = jj_consume_token(STRING_LITERAL);
      jj_consume_token(COMMA);
      g = jj_consume_token(STRING_LITERAL);
      jj_consume_token(COMMA);
      b = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
//        Color rgb = new Color(0,0,0);
        int rInt = -1;
        int gInt = -1;
        int bInt = -1;

        try {
            rInt = ScriptParserUtil.parseInt(r.image);
        }
        catch(ScriptParserException e) {
            ScriptError se = new ScriptError(e.getMessage(), r.beginLine, r.beginColumn);
            script.addError(se);
        }
        try {
            rInt = ScriptParserUtil.parseInt(g.image);
        }
        catch(ScriptParserException e) {
            ScriptError se = new ScriptError(e.getMessage(), g.beginLine, g.beginColumn);
            script.addError(se);
        }
        try {
            rInt = ScriptParserUtil.parseInt(b.image);
        }
        catch(ScriptParserException e) {
            ScriptError se = new ScriptError(e.getMessage(), b.beginLine, b.beginColumn);
            script.addError(se);
        }

        Color c = null;

        if(rInt != -1 && gInt != -1 && bInt != -1) {
            c = new Color(rInt, gInt, bInt);
        }

        {if (true) return c;}
    throw new Error("Missing return statement in function");
  }

  final public Color GetColor() throws ParseException {
    Color c;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BLACK:
    case BLUE:
    case DARK_GRAY:
    case GRAY:
    case GREEN:
    case LIGHT_GRAY:
    case MAGENTA:
    case ORANGE:
    case PINK:
    case RED:
    case WHITE:
    case YELLOW:
      c = GetStandardColor();
      break;
    case INTEGER_LITERAL:
    case STRING_LITERAL:
      c = GetRGB();
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return c;}
    throw new Error("Missing return statement in function");
  }

  final public void Canvas() throws ParseException {
    Token name = null;
    Token width = null;
    Token height = null;
    Color bgcolor = null;
    Color fgcolor = null;
    Token title = null;
    ArrayList attributes = new ArrayList();
    name = jj_consume_token(CANVAS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      attributes = CanvasAttributes();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      width = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      width = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      height = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      height = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    bgcolor = GetColor();
    jj_consume_token(COMMA);
    fgcolor = GetColor();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      title = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    jj_consume_token(RPAREN);
            ArrayList parameters = new ArrayList(4);

            if(bgcolor != null) {
                parameters.add(new JGSLColor("background", bgcolor));
            }
            else {
                parameters.add(new JGSLColor("background", Color.WHITE));
                ScriptWarning se = new ScriptWarning("Setting canvas background to WHITE.");
                script.addWarning(se);
            }

            if(fgcolor != null) {
                parameters.add(new JGSLColor("foreground", fgcolor));
            }
            else {
                parameters.add(new JGSLColor("foreground", Color.BLACK));
                ScriptWarning se = new ScriptWarning("Setting canvas foreground to BLACK.");
                script.addWarning(se);
            }

            addIntParam(parameters, "width", width);
            addIntParam(parameters, "height", height);

            if(title != null) {
                parameters.add(new JGSLString("title", title.image));
            }
            Command c = new Command(name.image, attributes, parameters);
            script.add(c);
  }

  final public ArrayList CanvasAttributes() throws ParseException {
    Token attrib;
    attrib = jj_consume_token(RED);
        ArrayList attributes = new ArrayList(1);
        {if (true) return attributes;}
    throw new Error("Missing return statement in function");
  }

  final public void Wait() throws ParseException {
    Token name;
    Token durationSeconds;
    name = jj_consume_token(WAIT);
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      durationSeconds = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      durationSeconds = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
        ArrayList parameters = new ArrayList(1);
        addIntParam(parameters, "duration", durationSeconds);
        Command c = new Command(name.image, parameters);
        script.add(c);
  }

  final public ArrayList DrawAttributes() throws ParseException {
    Token attrib;
    attrib = jj_consume_token(RED);
        ArrayList attributes = new ArrayList(1);
        {if (true) return attributes;}
    throw new Error("Missing return statement in function");
  }

  final public void Draw() throws ParseException {
    Token name;
    Token x;
    Token y;
    ArrayList attributes = new ArrayList();
    name = jj_consume_token(DRAW);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      attributes = DrawAttributes();
      break;
    default:
      jj_la1[13] = jj_gen;
      ;
    }
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      x = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      x = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[14] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      y = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      y = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[15] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
            ArrayList parameters = new ArrayList(2);
            addIntParam(parameters, "x", x);
            addIntParam(parameters, "y", y);
            addIntParam(parameters, "x", x);
            addIntParam(parameters, "y", y);
            Command c = new Command(name.image, attributes, parameters);
            script.add(c);
  }

//<COLON> (Attributes())? (<LPAREN> Parameters() <RPAREN>)?
  final public void Log() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOG:
      Message();
      break;
    case WARNING:
      Warning();
      break;
    case DEBUG:
      Debug();
      break;
    case ERROR:
      Error();
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Message() throws ParseException {
    Token name;
    Token message;
    name = jj_consume_token(LOG);
    jj_consume_token(LPAREN);
    message = jj_consume_token(STRING_LITERAL);
    jj_consume_token(RPAREN);
        ArrayList parameters = new ArrayList(1);
        parameters.add(new JGSLString("message", message.image));
        Command c = new Command(name.image, parameters);
        script.add(c);
  }

  final public void Warning() throws ParseException {
    Token name;
    Token message;
    name = jj_consume_token(WARNING);
    jj_consume_token(LPAREN);
    message = jj_consume_token(STRING_LITERAL);
    jj_consume_token(RPAREN);
        ArrayList parameters = new ArrayList(1);
        parameters.add(new JGSLString("message", message.image));
        Command c = new Command(name.image, parameters);
        script.add(c);
  }

  final public void Error() throws ParseException {
    Token name;
    Token message;
    name = jj_consume_token(ERROR);
    jj_consume_token(LPAREN);
    message = jj_consume_token(STRING_LITERAL);
    jj_consume_token(RPAREN);
        ArrayList parameters = new ArrayList(1);
        parameters.add(new JGSLString("message", message.image));
        Command c = new Command(name.image, parameters);
        script.add(c);
  }

  final public void Debug() throws ParseException {
    Token name;
    Token message;
    name = jj_consume_token(DEBUG);
    jj_consume_token(LPAREN);
    message = jj_consume_token(STRING_LITERAL);
    jj_consume_token(RPAREN);
        ArrayList parameters = new ArrayList(1);
        parameters.add(new JGSLString("message", message.image));
        Command c = new Command(name.image, parameters);
        script.add(c);
  }

  final public void DrawShape() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LINE:
      DrawLine();
      break;
    case RECTANGLE:
      DrawRectangle();
      break;
    case SQUARE:
      DrawSquare();
      break;
    case CIRCLE:
      DrawCircle();
      break;
    case ELIPSE:
      DrawElipse();
      break;
    case ARC:
      DrawArc();
      break;
    case POLYGON:
      DrawPolygon();
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void DrawLine() throws ParseException {
    Token name;
    Token x1;
    Token y1;
    Token x2;
    Token y2;
    ArrayList attributes = new ArrayList();
    name = jj_consume_token(LINE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      attributes = LineAttributes();
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      x1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      x1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      y1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      y1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      x2 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      x2 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      y2 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      y2 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
            ArrayList parameters = new ArrayList(4);
            addIntParam(parameters, "x1", x1);
            addIntParam(parameters, "y1", y1);
            addIntParam(parameters, "x2", x2);
            addIntParam(parameters, "y2", y2);
            Command c = new Command(name.image, attributes, parameters);
            script.add(c);
  }

  final public ArrayList LineAttributes() throws ParseException {
    Color c;
    c = GetColor();
        ArrayList attributes = new ArrayList(1);
        attributes.add(new JGSLColor("c", c));
        {if (true) return attributes;}
    throw new Error("Missing return statement in function");
  }

  final public void DrawRectangle() throws ParseException {
    Token name;
    Token x1;
    Token y1;
    Token width;
    Token height;
    ArrayList attributes = new ArrayList();
    name = jj_consume_token(RECTANGLE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      attributes = RectangleAttributes();
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      x1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      x1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[24] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      y1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      y1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      width = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      width = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      height = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      height = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[27] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
            ArrayList parameters = new ArrayList(4);
            addIntParam(parameters, "x1", x1);
            addIntParam(parameters, "y1", y1);
            addIntParam(parameters, "width", width);
            addIntParam(parameters, "height", height);
            Command c = new Command(name.image, attributes, parameters);
            script.add(c);
  }

  final public ArrayList RectangleAttributes() throws ParseException {
    Color c;
    c = GetColor();
        ArrayList attributes = new ArrayList(1);
        attributes.add(new JGSLColor("c", c));
        {if (true) return attributes;}
    throw new Error("Missing return statement in function");
  }

  final public void DrawSquare() throws ParseException {
    Token name;
    Token x1;
    Token y1;
    Token width;
    ArrayList attributes = new ArrayList();
    name = jj_consume_token(SQUARE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      attributes = SquareAttributes();
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      x1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      x1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[29] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      y1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      y1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      width = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      width = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
            ArrayList parameters = new ArrayList(4);
            addIntParam(parameters, "x1", x1);
            addIntParam(parameters, "y1", y1);
            addIntParam(parameters, "width", width);
            Command c = new Command(name.image, attributes, parameters);
            script.add(c);
  }

  final public ArrayList SquareAttributes() throws ParseException {
    Color c;
    c = GetColor();
        ArrayList attributes = new ArrayList(1);
        attributes.add(new JGSLColor("c", c));
        {if (true) return attributes;}
    throw new Error("Missing return statement in function");
  }

  final public void DrawCircle() throws ParseException {
    Token name;
    Token x1;
    Token y1;
    Token radius;
    ArrayList attributes = new ArrayList();
    name = jj_consume_token(CIRCLE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      attributes = CircleAttributes();
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      x1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      x1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[33] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      y1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      y1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      radius = jj_consume_token(FLOATING_POINT_LITERAL);
      break;
    case STRING_LITERAL:
      radius = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
            ArrayList parameters = new ArrayList(4);
            addIntParam(parameters, "x1", x1);
            addIntParam(parameters, "y1", y1);
            addDecimalParam(parameters, "radius", radius);
            Command c = new Command(name.image, attributes, parameters);
            script.add(c);
  }

  final public ArrayList CircleAttributes() throws ParseException {
    Color c;
    c = GetColor();
        ArrayList attributes = new ArrayList(1);
        attributes.add(new JGSLColor("c", c));
        {if (true) return attributes;}
    throw new Error("Missing return statement in function");
  }

  final public void DrawElipse() throws ParseException {
    Token name;
    Token x1;
    Token y1;
    Token width;
    Token height;
    ArrayList attributes = new ArrayList();
    name = jj_consume_token(ELIPSE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      attributes = ElipseAttributes();
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      x1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      x1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      y1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      y1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      width = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      width = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      height = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      height = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
            ArrayList parameters = new ArrayList(4);
            addIntParam(parameters, "x1", x1);
            addIntParam(parameters, "y1", y1);
            addIntParam(parameters, "width", width);
            addIntParam(parameters, "height", height);
            Command c = new Command(name.image, attributes, parameters);
            script.add(c);
  }

  final public ArrayList ElipseAttributes() throws ParseException {
    Color c;
    c = GetColor();
        ArrayList attributes = new ArrayList(1);
        attributes.add(new JGSLColor("c", c));
        {if (true) return attributes;}
    throw new Error("Missing return statement in function");
  }

  final public void DrawArc() throws ParseException {
    Token name;
    Token x1;
    Token y1;
    Token width;
    Token height;
    Token startAngle;
    Token arcAngle;
    ArrayList attributes = new ArrayList();
    name = jj_consume_token(ARC);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      attributes = ArcAttributes();
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      x1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      x1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      y1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      y1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      width = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      width = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[44] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      height = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      height = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      startAngle = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      startAngle = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      arcAngle = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      arcAngle = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(RPAREN);
            ArrayList parameters = new ArrayList(4);
            addIntParam(parameters, "x1", x1);
            addIntParam(parameters, "y1", y1);
            addIntParam(parameters, "width", width);
            addIntParam(parameters, "height", height);
            addIntParam(parameters, "startAngle", startAngle);
            addIntParam(parameters, "arcAngle", arcAngle);
            Command c = new Command(name.image, attributes, parameters);
            script.add(c);
  }

  final public ArrayList ArcAttributes() throws ParseException {
    Color c;
    c = GetColor();
        ArrayList attributes = new ArrayList(1);
        attributes.add(new JGSLColor("c", c));
        {if (true) return attributes;}
    throw new Error("Missing return statement in function");
  }

  final public void DrawPolygon() throws ParseException {
    Token name;
    Token x1;
    Token y1;
    Token width;
    Token height;
    Token startAngle;
    Token arcAngle;
    ArrayList attributes = new ArrayList();
    ArrayList parameters = new ArrayList();
    name = jj_consume_token(POLYGON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      attributes = PolygonAttributes();
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    jj_consume_token(LPAREN);
    PolygonParameters(parameters);
    jj_consume_token(RPAREN);
            Command c = new Command(name.image, attributes, parameters);
            script.add(c);
  }

  final public ArrayList PolygonAttributes() throws ParseException {
    Color c;
    c = GetColor();
        ArrayList attributes = new ArrayList(1);
        attributes.add(new JGSLColor("c", c));
        {if (true) return attributes;}
    throw new Error("Missing return statement in function");
  }

  final public void PolygonParameters(ArrayList parameters) throws ParseException {
    Token x1 = null;
    Token y1 = null;
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
      case STRING_LITERAL:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        x1 = jj_consume_token(INTEGER_LITERAL);
        break;
      case STRING_LITERAL:
        x1 = jj_consume_token(STRING_LITERAL);
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(COMMA);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER_LITERAL:
        y1 = jj_consume_token(INTEGER_LITERAL);
        break;
      case STRING_LITERAL:
        y1 = jj_consume_token(STRING_LITERAL);
        break;
      default:
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[52] = jj_gen;
        ;
      }
    }
        addIntParam(parameters, "x", x1);
        addIntParam(parameters, "y", y1);
  }

  final public void DrawText() throws ParseException {
    Token name;
    Token x1;
    Token y1;
    Token text;
    ArrayList attributes = new ArrayList();
    name = jj_consume_token(TEXT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      jj_consume_token(COLON);
      attributes = TextAttributes();
      break;
    default:
      jj_la1[53] = jj_gen;
      ;
    }
    jj_consume_token(LPAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      x1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      x1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      y1 = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      y1 = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(COMMA);
    text = jj_consume_token(STRING_LITERAL);
    jj_consume_token(RPAREN);
            ArrayList parameters = new ArrayList(3);
            addIntParam(parameters, "x1", x1);
            addIntParam(parameters, "y1", y1);
            parameters.add(new JGSLString("text", text.image));

            Command c = new Command(name.image, attributes, parameters);
            script.add(c);
  }

  void addIntParam(ArrayList parameters, String paramName, Token t) throws ParseException {
    try {
        if(t == null) {
            String msg = "Unable to convert value to a number.";
            ScriptError se = new ScriptError(msg, t.beginLine, t.beginColumn);
            script.addError(se);
        }
        parameters.add(new JGSLInteger(paramName, t.image));
    }
    catch(NumberFormatException e) {
        String msg = "Unable to convert value " + t.image + " to a number.";
        ScriptError se = new ScriptError(msg, t.beginLine, t.beginColumn);
        script.addError(se);
    }
  }

  void addDecimalParam(ArrayList parameters, String paramName, Token t) throws ParseException {
    try {
        parameters.add(new JGSLDouble(paramName, t.image));
    }
    catch(NumberFormatException e) {
        String msg = "Unable to convert value " + t.image + " to a number.";
        ScriptError se = new ScriptError(msg, t.beginLine, t.beginColumn);
        script.addError(se);
    }
  }

  final public ArrayList TextAttributes() throws ParseException {
    Color c;
    c = GetColor();
        ArrayList attributes = new ArrayList(1);
        attributes.add(new JGSLColor("c", c));
        {if (true) return attributes;}
    throw new Error("Missing return statement in function");
  }

  final public void Declaration() throws ParseException {
    jj_consume_token(DECLARE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLOR:
      DeclareColor();
      break;
    case IDENTIFIER:
      jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSIGN:
        jj_consume_token(ASSIGN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          jj_consume_token(IDENTIFIER);
          break;
        case INTEGER_LITERAL:
          jj_consume_token(INTEGER_LITERAL);
          break;
        case STRING_LITERAL:
          jj_consume_token(STRING_LITERAL);
          break;
        case FLOATING_POINT_LITERAL:
          jj_consume_token(FLOATING_POINT_LITERAL);
          break;
        default:
          jj_la1[56] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[57] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(SEMICOLON);
  }

  final public void DeclareCanvas() throws ParseException {
    Token type;
    Token id;
    Token tokenValue = null;
    type = jj_consume_token(CANVAS);
    id = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      tokenValue = jj_consume_token(CANVAS);
      break;
    default:
      jj_la1[59] = jj_gen;
      ;
    }
        String value = null;
        if(tokenValue != null) {
            value = tokenValue.image;
        }
        Declaration d = new Declaration(type.image, id.image, value);
        script.add(d);
  }

  final public void DeclareColor() throws ParseException {
    Token type;
    Token id;
    type = jj_consume_token(COLOR);
    id = jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      jj_consume_token(ASSIGN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BLACK:
      case BLUE:
      case DARK_GRAY:
      case GRAY:
      case GREEN:
      case LIGHT_GRAY:
      case MAGENTA:
      case ORANGE:
      case PINK:
      case RED:
      case WHITE:
      case YELLOW:
        DeclareStandardColor(type, id);
        break;
      case INTEGER_LITERAL:
      case STRING_LITERAL:
        DeclareRGB(type, id);
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[61] = jj_gen;
      ;
    }
  }

  final public void DeclareStandardColor(Token type, Token id) throws ParseException {
    Token value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BLACK:
      value = jj_consume_token(BLACK);
      break;
    case BLUE:
      value = jj_consume_token(BLUE);
      break;
    case DARK_GRAY:
      value = jj_consume_token(DARK_GRAY);
      break;
    case GRAY:
      value = jj_consume_token(GRAY);
      break;
    case GREEN:
      value = jj_consume_token(GREEN);
      break;
    case LIGHT_GRAY:
      value = jj_consume_token(LIGHT_GRAY);
      break;
    case MAGENTA:
      value = jj_consume_token(MAGENTA);
      break;
    case ORANGE:
      value = jj_consume_token(ORANGE);
      break;
    case PINK:
      value = jj_consume_token(PINK);
      break;
    case RED:
      value = jj_consume_token(RED);
      break;
    case WHITE:
      value = jj_consume_token(WHITE);
      break;
    case YELLOW:
      value = jj_consume_token(YELLOW);
      break;
    default:
      jj_la1[62] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        Declaration d = new Declaration(type.image, id.image, value.image);
        script.add(d);
  }

  final public void DeclareRGB(Token type, Token id) throws ParseException {
    Token r;
    Token g;
    Token b;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      r = jj_consume_token(INTEGER_LITERAL);
      jj_consume_token(COMMA);
      g = jj_consume_token(INTEGER_LITERAL);
      jj_consume_token(COMMA);
      b = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      r = jj_consume_token(STRING_LITERAL);
      jj_consume_token(COMMA);
      g = jj_consume_token(STRING_LITERAL);
      jj_consume_token(COMMA);
      b = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[63] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        String rgb = r.image + "," + g.image + "," + b.image;
        Declaration d = new Declaration(type.image, id.image, rgb);
        script.add(d);
  }

  final public void Assignment() throws ParseException {
    Token lhs;
    Token rhs;
    lhs = jj_consume_token(IDENTIFIER);
    jj_consume_token(ASSIGN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      rhs = jj_consume_token(IDENTIFIER);
      break;
    case INTEGER_LITERAL:
      rhs = jj_consume_token(INTEGER_LITERAL);
      break;
    case STRING_LITERAL:
      rhs = jj_consume_token(STRING_LITERAL);
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        Assignment a = new Assignment(lhs.image, rhs.image);
        script.add(a);
    jj_consume_token(SEMICOLON);
  }

  public JGSL_ParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[65];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x0,0xff800000,0xff800000,0xff800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x800,0x7f,0x7f,0x7f,0x7ff8000,0x0,0x7ff8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x78,0x3,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7ff8000,0x0,0x7ff8000,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x4,0x0,0x206,0x206,0x0,0x0,0x108,0x108,0x8000,0x108,0x108,0x10000,0x108,0x8000,0x108,0x108,0x0,0x0,0x8000,0x108,0x108,0x108,0x108,0x8000,0x108,0x108,0x108,0x108,0x8000,0x108,0x108,0x108,0x8000,0x108,0x108,0x180,0x8000,0x108,0x108,0x108,0x108,0x8000,0x108,0x108,0x108,0x108,0x108,0x108,0x8000,0x108,0x108,0x108,0x10000,0x8000,0x108,0x108,0x388,0x20000,0x201,0x20000,0x108,0x20000,0x0,0x108,0x308,};
   }

  public JGSL_Parser(java.io.InputStream stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new JGSL_ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  public JGSL_Parser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new JGSL_ParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  public JGSL_Parser(JGSL_ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  public void ReInit(JGSL_ParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 65; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[96];
    for (int i = 0; i < 96; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 65; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 96; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
